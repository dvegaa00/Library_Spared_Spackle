<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spared.processing.processing &mdash; SpaRED 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=2709fde1"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SpaRED
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">General</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SpaRED</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">spared.processing.processing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spared.processing.processing</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">anndata</span> <span class="k">as</span> <span class="nn">ad</span>
<span class="kn">from</span> <span class="nn">anndata.experimental.pytorch</span> <span class="kn">import</span> <span class="n">AnnLoader</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="c1">#from . import im_encoder</span>
<span class="kn">import</span> <span class="nn">torchvision.models</span> <span class="k">as</span> <span class="nn">tmodels</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">positional_encodings.torch_encodings</span> <span class="kn">import</span> <span class="n">PositionalEncoding2D</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">torch_geometric.data</span> <span class="kn">import</span> <span class="n">Data</span> <span class="k">as</span> <span class="n">geo_Data</span>
<span class="kn">from</span> <span class="nn">torch_geometric.loader</span> <span class="kn">import</span> <span class="n">DataLoader</span> <span class="k">as</span> <span class="n">geo_DataLoader</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">wget</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">from</span> <span class="nn">combat.pycombat</span> <span class="kn">import</span> <span class="n">pycombat</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">import</span> <span class="nn">squidpy</span> <span class="k">as</span> <span class="nn">sq</span>
<span class="kn">from</span> <span class="nn">torch_geometric.utils</span> <span class="kn">import</span> <span class="n">from_scipy_sparse_matrix</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="c1"># FIXME: Remove comments in spanish</span>

<span class="c1">#Get the path of the spared database</span>
<span class="c1">#SPARED_PATH = pathlib.Path(__file__).parent</span>

<span class="c1">#El path a spared es ahora diferente</span>
<span class="n">SPARED_PATH</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span>

<span class="c1">#Agregar el directorio padre al sys.path para los imports</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">))</span>
<span class="c1">#Import im_encoder.py file</span>
<span class="kn">from</span> <span class="nn">embeddings</span> <span class="kn">import</span> <span class="n">im_encoder</span>
<span class="c1"># Remove the path from sys.path</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">))</span>

<span class="c1">### Data analysis and filtering functions: </span>

<div class="viewcode-block" id="get_slide_from_collection">
<a class="viewcode-back" href="../../../api/spared.processing.get_slide_from_collection.html#spared.processing.get_slide_from_collection">[docs]</a>
<span class="k">def</span> <span class="nf">get_slide_from_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span>  <span class="n">slide</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Retrieve a slide from a collection of slides.</span>

<span class="sd">    This function receives a slide name and returns an AnnData object of the specified slide based on the collection of slides</span>
<span class="sd">    in the collection parameter.</span>

<span class="sd">    Args: </span>
<span class="sd">        collection (ad.AnnData): AnnData object with all the slides concatenated.</span>
<span class="sd">        slide (str): Name of the slide to get from the collection. Must be in the ``slide_id`` column of the ``collection.obs`` dataframe.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: An AnnData object with the specified slide.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the slide from the collection</span>
    <span class="n">slide_adata</span> <span class="o">=</span> <span class="n">collection</span><span class="p">[</span><span class="n">collection</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;slide_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">slide</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># Modify the uns dictionary to include only the information of the slide</span>
    <span class="n">slide_adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">slide</span><span class="p">:</span> <span class="n">collection</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">][</span><span class="n">slide</span><span class="p">]}</span>

    <span class="c1"># Return the slide</span>
    <span class="k">return</span> <span class="n">slide_adata</span></div>


<div class="viewcode-block" id="get_exp_frac">
<a class="viewcode-back" href="../../../api/spared.processing.get_exp_frac.html#spared.processing.get_exp_frac">[docs]</a>
<span class="k">def</span> <span class="nf">get_exp_frac</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the expression fraction for all genes.</span>

<span class="sd">    The expression fraction of a gene in a slide is defined as the proportion of spots where that gene is expressed. It is a number between ``0``</span>
<span class="sd">    and ``1`` where ``0`` means that the gene is not expressed in any spot and ``1`` means that the gene is expressed in all the spots.</span>

<span class="sd">    To compute an aggregation of expression fractions in a complete dataset, this function gets the</span>
<span class="sd">    expression fraction for each slide and then takes the minimum across all the slides. Hence the final number is a lower bound that ensures</span>
<span class="sd">    that the gene is expressed in at least that fraction of the spots in each of the slides.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): A slide collection where non-expressed genes have a value of ``0`` in the ``adata.X`` matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The updated slide collection with the added information into the ``adata.var[&#39;exp_frac&#39;]`` column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the unique slide ids</span>
    <span class="n">slide_ids</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;slide_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="c1"># Define zeros matrix of shape (n_genes, n_slides)</span>
    <span class="n">exp_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">slide_ids</span><span class="p">)))</span>

    <span class="c1"># Iterate over the slide ids</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slide_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slide_ids</span><span class="p">):</span>
        <span class="c1"># Get current slide adata</span>
        <span class="n">slide_adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;slide_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">slide_id</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Get current slide expression fraction</span>
        <span class="n">curr_exp_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">slide_adata</span><span class="o">.</span><span class="n">X</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">slide_adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">))</span>
        <span class="c1"># Add current slide expression fraction to the matrix</span>
        <span class="n">exp_frac</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_exp_frac</span>
    
    <span class="c1"># Compute the minimum expression fraction for each gene across all the slides</span>
    <span class="n">min_exp_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">exp_frac</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Add the minimum expression fraction to the var dataframe of the slide collection</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;exp_frac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_exp_frac</span>

    <span class="c1"># Return the adata</span>
    <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="get_glob_exp_frac">
<a class="viewcode-back" href="../../../api/spared.processing.get_glob_exp_frac.html#spared.processing.get_glob_exp_frac">[docs]</a>
<span class="k">def</span> <span class="nf">get_glob_exp_frac</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute the global expression fraction for all genes.</span>
<span class="sd">    </span>
<span class="sd">    This function computes the global expression fraction for each gene in a dataset.</span>

<span class="sd">    The global expression fraction of a gene in a dataset is defined as the proportion of spots where that gene is expressed. It is a number between ``0``</span>
<span class="sd">    and ``1`` where ``0`` means that the gene is not expressed in any spot and ``1`` means that the gene is expressed in all the spots. Its difference</span>
<span class="sd">    with the expression fraction is that the global expression fraction is computed for the whole dataset and not for each slide.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): A slide collection where a non-expressed genes have a value of ``0`` in the ``adata.X`` matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The updated slide collection with the information added into the  ``adata.var[&#39;glob_exp_frac&#39;]`` column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get global expression fraction</span>
    <span class="n">glob_exp_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">))</span>

    <span class="c1"># Add the global expression fraction to the var dataframe of the slide collection</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;glob_exp_frac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">glob_exp_frac</span>

    <span class="c1"># Return the adata</span>
    <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="filter_dataset">
<a class="viewcode-back" href="../../../api/spared.processing.filter_dataset.html#spared.processing.filter_dataset">[docs]</a>
<span class="k">def</span> <span class="nf">filter_dataset</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">param_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Perform complete filtering pipeline of a slide collection.</span>

<span class="sd">    This function takes a completely unfiltered and unprocessed (in raw counts) slide collection and filters it</span>
<span class="sd">    (both samples and genes) according to the ``param_dict`` argument.</span>
<span class="sd">    A summary list of the steps is the following:</span>

<span class="sd">        1. Filter out observations with ``total_counts`` outside the range ``[param_dict[&#39;cell_min_counts&#39;], param_dict[&#39;cell_max_counts&#39;]]``.</span>
<span class="sd">           This filters out low quality observations not suitable for analysis.</span>
<span class="sd">        2. Compute the ``exp_frac`` for each gene. This means that for each slide in the collection we compute the fraction of the spots that express each gene and then take the minimum across all the slides (see ``get_exp_frac`` function for more details).</span>
<span class="sd">        3. Compute the ``glob_exp_frac`` for each gene. This is similar to the ``exp_frac`` but instead of computing for each</span>
<span class="sd">           slide and taking the minimum we compute it for the whole collection. Slides don&#39;t matter here</span>
<span class="sd">           (see ``get_glob_exp_frac`` function for more details).</span>
<span class="sd">        4. Filter out genes depending on the ``param_dict[&#39;wildcard_genes&#39;]`` value, the options are the following:</span>

<span class="sd">            a. ``param_dict[&#39;wildcard_genes&#39;] == &#39;None&#39;``:</span>

<span class="sd">                - Filter out genes that are not expressed in at least ``param_dict[&#39;min_exp_frac&#39;]`` of spots in each slide.</span>
<span class="sd">                - Filter out genes that are not expressed in at least ``param_dict[&#39;min_glob_exp_frac&#39;]`` of spots in the whole collection.</span>
<span class="sd">                - Filter out genes with counts outside the range ``[param_dict[&#39;gene_min_counts&#39;], param_dict[&#39;gene_max_counts&#39;]]``</span>
<span class="sd">            b. ``param_dict[&#39;wildcard_genes&#39;] != &#39;None&#39;``:</span>

<span class="sd">                - Read ``.txt`` file specified by ``param_dict[&#39;wildcard_genes&#39;]`` and leave only the genes that are in this file.</span>
<span class="sd">        5. If there are spots with zero counts in all genes after gene filtering, remove them.</span>
<span class="sd">        6. Compute quality control metrics using scanpy&#39;s ``sc.pp.calculate_qc_metrics`` function.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): An unfiltered (unexpressed genes are encoded as ``0`` on the ``adata.X matrix``) slide collection.</span>
<span class="sd">        param_dict (dict): Dictionary that contains filtering and processing parameters. Keys that must be present are:</span>

<span class="sd">            - ``&#39;cell_min_counts&#39;`` (*int*):      Minimum total counts for a spot to be valid.</span>
<span class="sd">            - ``&#39;cell_max_counts&#39;`` (*int*):      Maximum total counts for a spot to be valid.</span>
<span class="sd">            - ``&#39;gene_min_counts&#39;`` (*int*):      Minimum total counts for a gene to be valid.</span>
<span class="sd">            - ``&#39;gene_max_counts&#39;`` (*int*):      Maximum total counts for a gene to be valid.</span>
<span class="sd">            - ``&#39;min_exp_frac&#39;`` (*float*):       Minimum fraction of spots in any slide that must express a gene for it to be valid.</span>
<span class="sd">            - ``&#39;min_glob_exp_frac&#39;`` (*float*):  Minimum fraction of spots in the whole collection that must express a gene for it to be valid.</span>
<span class="sd">            - ``&#39;wildcard_genes&#39;`` (*str*):       Path to a ``.txt`` file with the genes to keep or ``&#39;None&#39;`` to filter genes based on the other keys.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The filtered adata collection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Start tracking time</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting data filtering...&#39;</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

    <span class="c1"># Get initial gene and observation numbers</span>
    <span class="n">n_genes_init</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="n">n_obs_init</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span>

    <span class="c1">### Filter out samples:</span>

    <span class="c1"># Find indexes of cells with total_counts outside the range [cell_min_counts, cell_max_counts]</span>
    <span class="n">sample_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">bool_valid_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_counts</span> <span class="o">&gt;</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;cell_min_counts&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample_counts</span> <span class="o">&lt;</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;cell_max_counts&#39;</span><span class="p">])</span>
    <span class="n">valid_samples</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span><span class="p">[</span><span class="n">bool_valid_samples</span><span class="p">]</span>

    <span class="c1"># Subset the adata to keep only the valid samples</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">valid_samples</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1">### Filter out genes:</span>

    <span class="c1"># Compute the min expression fraction for each gene across all the slides</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">get_exp_frac</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
    <span class="c1"># Compute the global expression fraction for each gene</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">get_glob_exp_frac</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
    
    <span class="c1"># If no wildcard genes are specified then filter genes based in min_exp_frac and total counts</span>
    <span class="k">if</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;wildcard_genes&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        
        <span class="n">gene_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
                    
        <span class="c1"># Find indexes of genes with total_counts inside the range [gene_min_counts, gene_max_counts]</span>
        <span class="n">bool_valid_gene_counts</span> <span class="o">=</span> <span class="p">(</span><span class="n">gene_counts</span> <span class="o">&gt;</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;gene_min_counts&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gene_counts</span> <span class="o">&lt;</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;gene_max_counts&#39;</span><span class="p">])</span>
        <span class="c1"># Get the valid genes</span>
        <span class="n">valid_genes</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">[</span><span class="n">bool_valid_gene_counts</span><span class="p">]</span>
        
        <span class="c1"># Subset the adata to keep only the valid genes</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">valid_genes</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>     
    
        <span class="c1"># Filter by expression fractions - order by descending expression fraction</span>
        <span class="n">df_exp</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;exp_frac&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Calculate the mean glob_exp_frac of top expression fraction genes</span>
        <span class="n">df_exp</span><span class="p">[</span><span class="s1">&#39;Row&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_exp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">df_exp</span><span class="p">[</span><span class="s1">&#39;vol_real_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_exp</span><span class="p">[</span><span class="s1">&#39;glob_exp_frac&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">df_exp</span><span class="p">[</span><span class="s1">&#39;Row&#39;</span><span class="p">])</span>      
        <span class="n">df_exp</span> <span class="o">=</span> <span class="n">df_exp</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;Row&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Get the valid genes</span>
        <span class="n">num_genes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df_exp</span><span class="p">[</span><span class="s1">&#39;vol_real_data&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;real_data_percentage&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">valid_genes</span> <span class="o">=</span> <span class="n">df_exp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">num_genes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;gene_ids&#39;</span><span class="p">]</span>
        <span class="c1"># Subset the adata to keep only the valid genes</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">valid_genes</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># If there are wildcard genes then read them and subset the dataset to just use them</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Read valid wildcard genes</span>
        <span class="n">genes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;wildcard_genes&#39;</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Turn wildcard genes to pandas Index object</span>
        <span class="n">valid_genes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">genes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="c1"># Subset processed adata with wildcard genes</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">valid_genes</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1">### Remove cells with zero counts in all genes:</span>

    <span class="c1"># If there are cells with zero counts in all genes then remove them</span>
    <span class="n">null_cells</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">null_cells</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="o">~</span><span class="n">null_cells</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed </span><span class="si">{</span><span class="n">null_cells</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> cells with zero counts in all selected genes&quot;</span><span class="p">)</span>
    
    <span class="c1">### Compute quality control metrics:</span>

    <span class="c1"># As we have removed the majority of the genes, we recompute the quality metrics</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">calculate_qc_metrics</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">log1p</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">percent_top</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Print the number of genes and cells that survived the filtering</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Data filtering took </span><span class="si">{</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of genes that passed the filtering:        </span><span class="si">{</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">n_genes_init</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="mi">100</span><span class="o">*</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="o">/</span><span class="n">n_genes_init</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of observations that passed the filtering: </span><span class="si">{</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">n_obs_init</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="mi">100</span><span class="o">*</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="o">/</span><span class="n">n_obs_init</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adata</span></div>


<span class="c1">### Expression data processing functions:</span>

<span class="c1"># FIXME: Put the organism as a parameter instead of in the name of the dataset</span>
<div class="viewcode-block" id="tpm_normalization">
<a class="viewcode-back" href="../../../api/spared.processing.tpm_normalization.html#spared.processing.tpm_normalization">[docs]</a>
<span class="k">def</span> <span class="nf">tpm_normalization</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">to_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalize expression using TPM normalization.</span>

<span class="sd">    This function applies TPM normalization to an AnnData object with raw counts. It also removes genes that are not fount in the ``.gtf`` annotation file.</span>
<span class="sd">    The counts are taken from ``adata.layers[from_layer]`` and the results are stored in ``adata.layers[to_layer]``. It can perform the normalization</span>
<span class="sd">    for `human &lt;https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.basic.annotation.gtf.gz&gt;`_ and `mouse</span>
<span class="sd">    &lt;https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M33/gencode.vM33.basic.annotation.gtf.gz&gt;`_ reference genomes.</span>
<span class="sd">    To specify which GTF annotation file should be used, the string parameter ``&#39;dataset&#39;`` must contain the substring ``&#39;mouse&#39;`` or ``&#39;human&#39;``.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (str): The dataset name. Must contain the substring ``&#39;mouse&#39;`` or ``&#39;human&#39;`` to specify the reference genome.</span>
<span class="sd">        adata (ad.Anndata): The Anndata object to normalize.</span>
<span class="sd">        from_layer (str): The layer to take the counts from. The data in this layer should be in raw counts.</span>
<span class="sd">        to_layer (str): The layer to store the results of the normalization.</span>
<span class="sd">    Returns:</span>
<span class="sd">        ad.Anndata: The updated Anndata object with TPM values in ``adata.layers[to_layer]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Get the number of genes before filtering</span>
    <span class="n">initial_genes</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Automatically download the gtf annotation file if it is not already downloaded</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;gencode.v43.basic.annotation.gtf.gz&#39;</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Automatically downloading gtf annotation file...&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">wget</span><span class="o">.</span><span class="n">download</span><span class="p">(</span>
            <span class="s1">&#39;https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.basic.annotation.gtf.gz&#39;</span><span class="p">,</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;gencode.v43.basic.annotation.gtf.gz&#39;</span><span class="p">))</span>

    <span class="c1"># Define gtf human path</span>
    <span class="n">gtf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;gencode.v43.basic.annotation.gtf&#39;</span><span class="p">)</span>

    <span class="c1"># Unzip the data in annotations folder if it is not already unzipped</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gtf_path</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;gencode.v43.basic.annotation.gtf.gz&#39;</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_in</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gtf_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_out</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copyfileobj</span><span class="p">(</span><span class="n">f_in</span><span class="p">,</span> <span class="n">f_out</span><span class="p">)</span>

    <span class="c1"># FIXME: Set up automatic download of mouse gtf file</span>
    <span class="c1"># Define gtf mouse path</span>
    <span class="n">gtf_path_mouse</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;gencode.vM33.basic.annotation.gtf&#39;</span><span class="p">)</span>

    <span class="c1"># Unzip the data in annotations folder if it is not already unzipped</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gtf_path_mouse</span><span class="p">):</span>            
        <span class="k">with</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;gencode.vM33.basic.annotation.gtf.gz&#39;</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_in</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gtf_path_mouse</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_out</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copyfileobj</span><span class="p">(</span><span class="n">f_in</span><span class="p">,</span> <span class="n">f_out</span><span class="p">)</span>

    <span class="c1"># Obtain a txt with gene lengths</span>
    <span class="n">gene_length_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_length.txt&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gene_length_path</span><span class="p">):</span>
        <span class="n">command</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;python </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gtftools.py&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1"> -l </span><span class="si">{</span><span class="n">gene_length_path</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">gtf_path</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">command_list</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">command_list</span><span class="p">)</span>   

    <span class="n">gene_length_path_mouse</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_length_mouse.txt&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gene_length_path_mouse</span><span class="p">):</span>
        <span class="n">command</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;python </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SPARED_PATH</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gtftools.py&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1"> -l </span><span class="si">{</span><span class="n">gene_length_path_mouse</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">gtf_path_mouse</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">command_list</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">command_list</span><span class="p">)</span> 

    <span class="c1"># Upload the gene lengths</span>
    <span class="k">if</span> <span class="s2">&quot;mouse&quot;</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="n">glength_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">gene_length_path_mouse</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="s1">&#39;merged&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">glength_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">gene_length_path</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="s1">&#39;merged&#39;</span><span class="p">])</span>

    <span class="c1"># For the gene column, remove the version number</span>
    <span class="n">glength_df</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">glength_df</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Drop gene duplicates. NOTE: This only eliminates 40/60k genes so it is not a big deal</span>
    <span class="n">glength_df</span> <span class="o">=</span> <span class="n">glength_df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gene&#39;</span><span class="p">])</span>

    <span class="c1"># Find the genes that are in the gtf annotation file</span>
    <span class="n">common_genes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span><span class="o">&amp;</span><span class="nb">set</span><span class="p">(</span><span class="n">glength_df</span><span class="p">[</span><span class="s2">&quot;gene&quot;</span><span class="p">]))</span>

    <span class="c1"># Subset both adata and glength_df to keep only the common genes</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">common_genes</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">glength_df</span> <span class="o">=</span> <span class="n">glength_df</span><span class="p">[</span><span class="n">glength_df</span><span class="p">[</span><span class="s2">&quot;gene&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">common_genes</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Reindex the glength_df to genes</span>
    <span class="n">glength_df</span> <span class="o">=</span> <span class="n">glength_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;gene&#39;</span><span class="p">)</span>
    <span class="c1"># Reindex glength_df to adata.var_names</span>
    <span class="n">glength_df</span> <span class="o">=</span> <span class="n">glength_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
    <span class="c1"># Assert indexes of adata.var and glength_df are the same</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">glength_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="c1"># Add gene lengths to adata.var</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;gene_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">glength_df</span><span class="p">[</span><span class="s1">&#39;merged&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># Divide each column of the counts matrix by the gene length. Save the result in layer &quot;to_layer&quot;</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">from_layer</span><span class="p">]</span> <span class="o">/</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;gene_length&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Make that each row sums to 1e6</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">1e6</span><span class="p">))</span>
    <span class="c1"># Pass layer to np.array</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">])</span>

    <span class="c1"># Print the number of genes that were not found in the gtf annotation file</span>
    <span class="n">failed_genes</span> <span class="o">=</span> <span class="n">initial_genes</span> <span class="o">-</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of genes not found in GTF file by TPM normalization: </span><span class="si">{</span><span class="n">initial_genes</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="si">}</span><span class="s1"> out of </span><span class="si">{</span><span class="n">initial_genes</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="mi">100</span><span class="o">*</span><span class="n">failed_genes</span><span class="o">/</span><span class="n">initial_genes</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">%) (</span><span class="si">{</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="si">}</span><span class="s1"> remaining)&#39;</span><span class="p">)</span>

    <span class="c1"># Return the transformed AnnData object</span>
    <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="log1p_transformation">
<a class="viewcode-back" href="../../../api/spared.processing.log1p_transformation.html#spared.processing.log1p_transformation">[docs]</a>
<span class="k">def</span> <span class="nf">log1p_transformation</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">to_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform :math:`\log_2(x+1)` transformation </span>

<span class="sd">    Performs logarithmic transformation over ``adata.layers[from_layer]``. Simple wrapper of scanpy&#39;s ``sc.pp.log1p()``</span>
<span class="sd">    (base 2) to transform data from ``adata.layers[from_layer]`` and save it into ``adata.layers[to_layer]``.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to transform.</span>
<span class="sd">        from_layer (str): The layer to take the data from.</span>
<span class="sd">        to_layer (str): The layer to store the results of the transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The updated AnnData object with transformed data in ``adata.layers[to_layer]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Transform the data with log1p</span>
    <span class="n">transformed_adata</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">from_layer</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Add the log1p transformed data to adata.layers[to_layer]</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed_adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">from_layer</span><span class="p">]</span>

    <span class="c1"># Return the transformed AnnData object</span>
    <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="clean_noise">
<a class="viewcode-back" href="../../../api/spared.processing.clean_noise.html#spared.processing.clean_noise">[docs]</a>
<span class="k">def</span> <span class="nf">clean_noise</span><span class="p">(</span><span class="n">collection</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">to_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove noise with median filter.</span>

<span class="sd">    Function that cleans noise (missing data) with a modified adaptive median filter for each slide in an AnnData collection.</span>
<span class="sd">    Details of the adaptive median filter can be found in the ``adaptive_median_filter_pepper()`` function inside the source code.</span>
<span class="sd">    The data will be taken from ``adata.layers[from_layer]`` and the results will be stored in ``adata.layers[to_layer]``.</span>

<span class="sd">    Args:</span>
<span class="sd">        collection (ad.AnnData): The AnnData collection to process.</span>
<span class="sd">        from_layer (str): The layer to compute the adaptive median filter from. Where to clean the noise from.</span>
<span class="sd">        to_layer (str): The layer to store the results of the adaptive median filter. Where to store the cleaned data.</span>
<span class="sd">        n_hops (int): The maximum number of concentric rings in the neighbors graph to take into account to compute the median. Analogous to the maximum window size.</span>
<span class="sd">        hex_geometry (bool): ``True``, if the graph has hexagonal spatial geometry (Visium technology). If False, then the graph is a grid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: New AnnData collection with the results of the adaptive median filter stored in the layer ``adata.layers[to_layer]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># FIXME: This function can be used alone. Think of getting it outside.</span>
    <span class="c1">### Define function to get spatial neighbors in an AnnData object</span>
    <span class="k">def</span> <span class="nf">get_spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes a neighbors dictionary for an AnnData object. The neighbors are computed according to topological distances over</span>
<span class="sd">        a graph defined by the hex_geometry connectivity. The neighbors dictionary is a dictionary where the keys are the indexes of the observations</span>
<span class="sd">        and the values are lists of the indexes of the neighbors of each observation. The neighbors include the observation itself and are found</span>
<span class="sd">        inside an n_hops neighborhood (vicinity) of the observation.</span>

<span class="sd">        Args:</span>
<span class="sd">            adata (ad.AnnData): The AnnData object to process. Importantly it is only from a single slide. Can not be a collection of slides.</span>
<span class="sd">            n_hops (int): The size of the neighborhood to take into account to compute the neighbors.</span>
<span class="sd">            hex_geometry (bool): Whether the graph is hexagonal or not. If True, then the graph is hexagonal. If False, then the graph is a grid. Only</span>
<span class="sd">                                 true for visium datasets.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: The neighbors dictionary. The keys are the indexes of the observations and the values are lists of the indexes of the neighbors of each observation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute spatial_neighbors</span>
        <span class="k">if</span> <span class="n">hex_geometry</span><span class="p">:</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s1">&#39;generic&#39;</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span> <span class="c1"># Hexagonal visium case</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># Grid dataset case</span>

        <span class="c1"># Get the adjacency matrix</span>
        <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s1">&#39;spatial_connectivities&#39;</span><span class="p">]</span>

        <span class="c1"># Define power matrix</span>
        <span class="n">power_matrix</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Define the output matrix</span>
        <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Iterate through the hops</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_hops</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Compute the next hop</span>
            <span class="n">power_matrix</span> <span class="o">=</span> <span class="n">power_matrix</span> <span class="o">*</span> <span class="n">adj_matrix</span>
            <span class="c1"># Add the next hop to the output matrix</span>
            <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">output_matrix</span> <span class="o">+</span> <span class="n">power_matrix</span>

        <span class="c1"># Zero out the diagonal</span>
        <span class="n">output_matrix</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Threshold the matrix to 0 and 1</span>
        <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">output_matrix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Define neighbors dict</span>
        <span class="n">neighbors_dict_index</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Iterate through the rows of the output matrix</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">output_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Get the non-zero elements of the row</span>
            <span class="n">non_zero_elements</span> <span class="o">=</span> <span class="n">output_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Add the neighbors to the neighbors dicts. NOTE: the first index is the query obs</span>
            <span class="n">neighbors_dict_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">non_zero_elements</span><span class="p">)</span>
        
        <span class="c1"># Return the neighbors dict</span>
        <span class="k">return</span> <span class="n">neighbors_dict_index</span>

    <span class="c1">### Define cleaning function for single slide:</span>
    <span class="k">def</span> <span class="nf">adaptive_median_filter_pepper</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">to_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes a modified adaptive median filter for pairs (obs, gene) with a zero value (peper noise) in the layer &#39;from_layer&#39; and</span>
<span class="sd">        stores the result in the layer &#39;to_layer&#39;. The max window size is a neighborhood of n_hops defined by the conectivity (hexagonal or grid).</span>
<span class="sd">        This means the number of concentric rings in a graph to take into account to compute the median.</span>

<span class="sd">        The adaptive median filter denoises each gene independently. In other words gene A has no influence on the denoising of gene B.</span>

<span class="sd">        Args:</span>
<span class="sd">            adata (ad.AnnData): The AnnData object to process. Importantly it is only from a single slide. Can not be a collection of slides.</span>
<span class="sd">            from_layer (str): The layer to compute the adaptive median filter from.</span>
<span class="sd">            to_layer (str): The layer to store the results of the adaptive median filter.</span>
<span class="sd">            n_hops (int): The maximum number of concentric rings in the graph to take into account to compute the median. Analogous to the max window size.</span>
<span class="sd">            hex_geometry (bool): Whether the graph is hexagonal or not. If True, then the graph is hexagonal. If False, then the graph is a grid. Only</span>
<span class="sd">                                 true for visium datasets.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ad.AnnData: The AnnData object with the results of the adaptive median filter stored in the layer &#39;to_layer&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define original expression matrix</span>
        <span class="n">original_exp</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">from_layer</span><span class="p">]</span>    

        <span class="n">medians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="p">))</span>

        <span class="c1"># Iterate over the hops</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_hops</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="c1"># Get dictionary of neighbors for a given number of hops</span>
            <span class="n">curr_neighbors_dict</span> <span class="o">=</span> <span class="n">get_spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">)</span>

            <span class="c1"># Iterate over observations</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">):</span>
                <span class="c1"># Get the list of indexes of the neighbors of the j&#39;th observation</span>
                <span class="n">neighbors_idx</span> <span class="o">=</span> <span class="n">curr_neighbors_dict</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1"># Get the expression matrix of the neighbors</span>
                <span class="n">neighbor_exp</span> <span class="o">=</span> <span class="n">original_exp</span><span class="p">[</span><span class="n">neighbors_idx</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># Get the median of the expression matrix</span>
                <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">neighbor_exp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Store the median in the medians matrix</span>
                <span class="n">medians</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">median</span>
        
        <span class="c1"># Also robustly compute the median of the non-zero values for each gene</span>
        <span class="n">general_medians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">v</span><span class="p">)]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">original_exp</span><span class="p">)</span>
        <span class="n">general_medians</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">general_medians</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># Correct for possible nans</span>

        <span class="c1"># Define corrected expression matrix</span>
        <span class="n">corrected_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">original_exp</span><span class="p">)</span>

        <span class="c1">### Now that all the possible medians are computed. We code for each observation:</span>
        
        <span class="c1"># Note: i indexes over observations, j indexes over genes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="p">):</span>
                
                <span class="c1"># Get real expression value</span>
                <span class="n">z_xy</span> <span class="o">=</span> <span class="n">original_exp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                <span class="c1"># Only apply adaptive median filter if real expression is zero</span>
                <span class="k">if</span> <span class="n">z_xy</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">corrected_exp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_xy</span>
                    <span class="k">continue</span>
                
                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># Definie initial stage and window size</span>
                    <span class="n">current_stage</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

                        <span class="c1"># Stage A:</span>
                        <span class="k">if</span> <span class="n">current_stage</span> <span class="o">==</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span>
                            
                            <span class="c1"># Get median value</span>
                            <span class="n">z_med</span> <span class="o">=</span> <span class="n">medians</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                            <span class="c1"># If median is not zero then go to stage B</span>
                            <span class="k">if</span> <span class="n">z_med</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">current_stage</span> <span class="o">=</span> <span class="s1">&#39;B&#39;</span>
                                <span class="k">continue</span>
                            <span class="c1"># If median is zero, then increase window and repeat stage A</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_hops</span><span class="p">:</span>
                                    <span class="n">current_stage</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>
                                    <span class="k">continue</span>
                                <span class="c1"># If we have the biggest window size, then return the median</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="c1"># NOTE: Big modification to the median filter here. Be careful</span>
                                    <span class="n">corrected_exp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">general_medians</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                                    <span class="k">break</span>


                        <span class="c1"># Stage B:</span>
                        <span class="k">elif</span> <span class="n">current_stage</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span>
                            
                            <span class="c1"># Get window median</span>
                            <span class="n">z_med</span> <span class="o">=</span> <span class="n">medians</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                            <span class="c1"># If real expression is not peper then return it</span>
                            <span class="k">if</span> <span class="n">z_xy</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">corrected_exp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_xy</span>
                                <span class="k">break</span>
                            <span class="c1"># If real expression is peper, then return the median</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">corrected_exp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_med</span>
                                <span class="k">break</span>

        <span class="c1"># Add corrected expression to adata</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrected_exp</span>

        <span class="k">return</span> <span class="n">adata</span>

    <span class="c1"># Print message</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Applying adaptive median filter to collection...&#39;</span><span class="p">)</span>

    <span class="c1"># Get the unique slides</span>
    <span class="n">slides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;slide_id&#39;</span><span class="p">])</span>

    <span class="c1"># Define the corrected adata list</span>
    <span class="n">corrected_adata_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over the slides</span>
    <span class="k">for</span> <span class="n">slide</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">slides</span><span class="p">):</span>
        <span class="c1"># Get the adata of the slide</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">collection</span><span class="p">[</span><span class="n">collection</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;slide_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">slide</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Apply adaptive median filter</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adaptive_median_filter_pepper</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">,</span> <span class="n">to_layer</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">)</span>
        <span class="c1"># Append to the corrected adata list</span>
        <span class="n">corrected_adata_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
    
    <span class="c1"># Concatenate the corrected adata list</span>
    <span class="n">corrected_collection</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">corrected_adata_list</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
    <span class="c1"># Restore the uns attribute</span>
    <span class="n">corrected_collection</span><span class="o">.</span><span class="n">uns</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">uns</span>

    <span class="k">return</span> <span class="n">corrected_collection</span></div>


<div class="viewcode-block" id="combat_transformation">
<a class="viewcode-back" href="../../../api/spared.processing.combat_transformation.html#spared.processing.combat_transformation">[docs]</a>
<span class="k">def</span> <span class="nf">combat_transformation</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">batch_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">to_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Perform batch correction with ComBat</span>

<span class="sd">    Compute batch correction using the `pycombat &lt;https://github.com/epigenelabs/pyComBat?tab=readme-ov-file&gt;`_ package. The batches are defined by ``adata.obs[batch_key]`` so</span>
<span class="sd">    the user can define which variable to use as batch identifier. The input data for the batch correction is ``adata.layers[from_layer]`` and the output is stored in</span>
<span class="sd">    ``adata.layers[to_layer]``.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to transform. Must have logarithmically transformed data in ``adata.layers[from_layer]``.</span>
<span class="sd">        batch_key (str): The column in ``adata.obs`` that defines the batches.</span>
<span class="sd">        from_layer (str): The layer to take the data from.</span>
<span class="sd">        to_layer (str): The layer to store the results of the transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The updated AnnData object with batch corrected data in ``adata.layers[to_layer]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get expression matrix dataframe</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">to_df</span><span class="p">(</span><span class="n">layer</span> <span class="o">=</span> <span class="n">from_layer</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">batch_list</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">batch_key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Apply pycombat batch correction</span>
    <span class="n">corrected_df</span> <span class="o">=</span> <span class="n">pycombat</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">batch_list</span><span class="p">,</span> <span class="n">par_prior</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Assign batch corrected expression to .layers[to_layer] attribute</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrected_df</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="get_deltas">
<a class="viewcode-back" href="../../../api/spared.processing.get_deltas.html#spared.processing.get_deltas">[docs]</a>
<span class="k">def</span> <span class="nf">get_deltas</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">to_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get expression deltas from the mean.</span>

<span class="sd">    Compute the deviations from the mean expression of each gene in ``adata.layers[from_layer]`` and save them</span>
<span class="sd">    in ``adata.layers[to_layer]``. Also add the mean expression of each gene to ``adata.var[f&#39;{from_layer}_avg_exp&#39;]``.</span>
<span class="sd">    Average expression is computed using only train data determined by the ``adata.obs[&#39;split&#39;]`` column. However, deltas</span>
<span class="sd">    are computed for all observations.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to update. Must have expression values in ``adata.layers[from_layer]``. Must also have the ``adata.obs[&#39;split&#39;]`` column with ``&#39;train&#39;`` values.</span>
<span class="sd">        from_layer (str): The layer to take the data from.</span>
<span class="sd">        to_layer (str): The layer to store the results of the transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The updated AnnData object with the deltas (``adata.layers[to_layer]``) and mean expression (``adata.var[f&#39;{from_layer}_avg_exp&#39;]``) information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the expression matrix of both train and global data</span>
    <span class="n">glob_expression</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">to_df</span><span class="p">(</span><span class="n">layer</span><span class="o">=</span><span class="n">from_layer</span><span class="p">)</span>
    <span class="n">train_expression</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;split&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;train&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_df</span><span class="p">(</span><span class="n">layer</span><span class="o">=</span><span class="n">from_layer</span><span class="p">)</span>

    <span class="c1"># Define scaler</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">(</span><span class="n">with_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_std</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Fit the scaler to the train data</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_expression</span><span class="p">)</span>
    
    <span class="c1"># Get the centered expression matrix of the global data</span>
    <span class="n">centered_expression</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">glob_expression</span><span class="p">)</span>

    <span class="c1"># Add the deltas to adata.layers[to_layer]	</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">to_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">centered_expression</span>

    <span class="c1"># Add the mean expression to adata.var[f&#39;{from_layer}_avg_exp&#39;]</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_layer</span><span class="si">}</span><span class="s1">_avg_exp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">mean_</span>

    <span class="c1"># Return the updated AnnData object</span>
    <span class="k">return</span> <span class="n">adata</span></div>


<div class="viewcode-block" id="compute_moran">
<a class="viewcode-back" href="../../../api/spared.processing.compute_moran.html#spared.processing.compute_moran">[docs]</a>
<span class="k">def</span> <span class="nf">compute_moran</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Moran&#39;s I statistic for each gene.</span>

<span class="sd">    Compute average Moran&#39;s I statistic for a collection of slides. Internally cycles over each slide in the ``adata`` collection</span>
<span class="sd">    and computes the Moran&#39;s I statistic for each gene. After that, it averages the Moran&#39;s I for each gene across all</span>
<span class="sd">    slides and saves it in ``adata.var[f&#39;{from_layer}_moran&#39;]``.The input data for the Moran&#39;s I computation is ``adata.layers[from_layer]``.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to update. Must have expression values in ``adata.layers[from_layer]``.</span>
<span class="sd">        from_layer (str): The key in ``adata.layers`` with the values used to compute Moran&#39;s I.</span>
<span class="sd">        hex_geometry (bool): Whether the geometry is hexagonal or not. This is used to compute the spatial neighbors before computing Moran&#39;s I. Only ``True`` for visium datasets.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The updated AnnData object with the average Moran&#39;s I for each gene in ``adata.var[f&#39;{from_layer}_moran&#39;]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Computing Moran</span><span class="se">\&#39;</span><span class="s1">s I for each gene over each slide using data of layer </span><span class="si">{</span><span class="n">from_layer</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>

    <span class="c1"># Get the unique slide_ids</span>
    <span class="n">slide_ids</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;slide_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="c1"># Create a dataframe to store the Moran&#39;s I for each slide</span>
    <span class="n">moran_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">slide_ids</span><span class="p">)</span>

    <span class="c1"># Cycle over each slide</span>
    <span class="k">for</span> <span class="n">slide</span> <span class="ow">in</span> <span class="n">slide_ids</span><span class="p">:</span>
        <span class="c1"># Get the annData for the current slide</span>
        <span class="n">slide_adata</span> <span class="o">=</span> <span class="n">get_slide_from_collection</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">slide</span><span class="p">)</span>
        <span class="c1"># Compute spatial_neighbors</span>
        <span class="k">if</span> <span class="n">hex_geometry</span><span class="p">:</span>
            <span class="c1"># Hexagonal visium case</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">slide_adata</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s1">&#39;generic&#39;</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Grid STNet dataset case</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">slide_adata</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="c1"># Compute Moran&#39;s I</span>
        <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_autocorr</span><span class="p">(</span>
            <span class="n">slide_adata</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;moran&quot;</span><span class="p">,</span>
            <span class="n">layer</span><span class="o">=</span><span class="n">from_layer</span><span class="p">,</span>
            <span class="n">genes</span><span class="o">=</span><span class="n">slide_adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span>
            <span class="n">n_perms</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="mi">42</span>
        <span class="p">)</span>

        <span class="c1"># Get moran I</span>
        <span class="n">moranI</span> <span class="o">=</span> <span class="n">slide_adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;moranI&#39;</span><span class="p">][</span><span class="s1">&#39;I&#39;</span><span class="p">]</span>
        <span class="c1"># Reindex moranI to match the order of the genes in the adata object</span>
        <span class="n">moranI</span> <span class="o">=</span> <span class="n">moranI</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Add the Moran&#39;s I to the dataframe</span>
        <span class="n">moran_df</span><span class="p">[</span><span class="n">slide</span><span class="p">]</span> <span class="o">=</span> <span class="n">moranI</span>

    <span class="c1"># Compute the average Moran&#39;s I for each gene</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_layer</span><span class="si">}</span><span class="s1">_moran&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">moran_df</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Return the updated AnnData object</span>
    <span class="k">return</span> <span class="n">adata</span></div>


<span class="c1"># TODO: Fix documentation when the internal fixme is solved</span>
<div class="viewcode-block" id="filter_by_moran">
<a class="viewcode-back" href="../../../api/spared.processing.filter_by_moran.html#spared.processing.filter_by_moran">[docs]</a>
<span class="k">def</span> <span class="nf">filter_by_moran</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">n_keep</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">from_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Filter prediction genes by Moran&#39;s I.</span>

<span class="sd">    This function filters the genes in ``adata.var`` by the Moran&#39;s I statistic. It keeps the ``n_keep`` genes with the highest Moran&#39;s I.</span>
<span class="sd">    The Moran&#39;s I values will be selected from ``adata.var[f&#39;{from_layer}_moran&#39;]`` which must be already present in the ``adata``.</span>
<span class="sd">    If ``n_keep &lt;= 0``, it means the number of genes is no specified and wee proceed to automatically compute it in the following way:</span>
<span class="sd">    </span>
<span class="sd">        a. If ``adata.n_vars &gt; 320`` then ``n_keep = 128``.</span>
<span class="sd">        b. else, ``n_keep = 32``. </span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to update. Must have ``adata.var[f&#39;{from_layer}_moran&#39;]`` column.</span>
<span class="sd">        n_keep (int): The number of genes to keep. I less than ``0`` the number of genes to keep is computed automatically.</span>
<span class="sd">        from_layer (str): Layer for which the Moran&#39;s I was already computed (``adata.var[f&#39;{from_layer}_moran&#39;]``).</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The updated AnnData object with the filtered genes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Assert that the number of genes is at least n_keep</span>
    <span class="k">assert</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">&gt;=</span> <span class="n">n_keep</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;The number of genes in the AnnData object is </span><span class="si">{</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="si">}</span><span class="s1">, which is less than n_keep (</span><span class="si">{</span><span class="n">n_keep</span><span class="si">}</span><span class="s1">).&#39;</span>

    <span class="c1"># FIXME: This part is wierd, we can define a simple threshold without all the computation</span>
    <span class="c1"># Select amount of top genes depending on the available amount if n_keep is not specified</span>
    <span class="k">if</span> <span class="n">n_keep</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_keep</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_keep</span> <span class="o">-</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_keep</span> <span class="o">-</span> <span class="mi">32</span><span class="p">):</span>
            <span class="n">n_keep</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_keep</span> <span class="o">=</span> <span class="mi">128</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering genes by Moran&#39;s I. Keeping top </span><span class="si">{</span><span class="n">n_keep</span><span class="si">}</span><span class="s2"> genes.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Sort the genes by Moran&#39;s I</span>
    <span class="n">sorted_genes</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_layer</span><span class="si">}</span><span class="s1">_moran&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>

    <span class="c1"># Get genes to keep list</span>
    <span class="n">genes_to_keep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sorted_genes</span><span class="p">[:</span><span class="n">n_keep</span><span class="p">])</span>

    <span class="c1"># Filter the genes andata object</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">genes_to_keep</span><span class="p">]</span>

    <span class="c1"># Return the updated AnnData object</span>
    <span class="k">return</span> <span class="n">adata</span></div>



<span class="c1"># TODO: Fix documentation when the internal fixme is solved. Another option is to put this function inside the initial preprocessing.</span>
<div class="viewcode-block" id="add_noisy_layer">
<a class="viewcode-back" href="../../../api/spared.processing.add_noisy_layer.html#spared.processing.add_noisy_layer">[docs]</a>
<span class="k">def</span> <span class="nf">add_noisy_layer</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">prediction_layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Add an artificial noisy layer.</span>
<span class="sd">    This function should only be used for experimentation/ablation purposes. It adds a noisy layer to the adata object by the name of &#39;noisy_d&#39;</span>
<span class="sd">    or &#39;noisy&#39; depending on the prediction layer. The noisy layer is created by returning the missing values to an already denoised layer of the adata.</span>
<span class="sd">    In the case the source layer is on logarithmic scale, the noisy layer is created by assigning zero values to the missing values. In the case the source</span>
<span class="sd">    layer is on delta scale, the noisy layer is created by assigning the negative mean of the gene to the missing values. missing values are specified by</span>
<span class="sd">    the binary ada.layers[&#39;mask&#39;] layer.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to update. Must have the prediction layer, the gene means if its a delta layer, and the mask layer.</span>
<span class="sd">        prediction_layer (str): The layer that will be corrupted to create the noisy layer.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.AnnData: The updated AnnData object with the noisy layer added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;delta&#39;</span> <span class="ow">in</span> <span class="n">prediction_layer</span> <span class="ow">or</span> <span class="s1">&#39;noisy_d&#39;</span> <span class="ow">in</span> <span class="n">prediction_layer</span><span class="p">:</span>
    <span class="c1"># FIXME: make it flexible for other prediction layers different to c_d_log1p</span>
        <span class="c1"># Get vector with gene means</span>
        <span class="n">gene_means</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;c_d_log1p_avg_exp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> 
        <span class="c1"># Expand gene means to the shape of the layer</span>
        <span class="n">gene_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">gene_means</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Get valid mask</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
        <span class="c1"># Initialize noisy deltas</span>
        <span class="n">noisy_deltas</span> <span class="o">=</span> <span class="o">-</span><span class="n">gene_means</span> 
        <span class="c1"># Assign delta values in positions where valid mask is true</span>
        <span class="n">noisy_deltas</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;c_d_deltas&#39;</span><span class="p">][</span><span class="n">valid_mask</span><span class="p">]</span>
        <span class="c1"># Add the layer to the adata</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;noisy_d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noisy_deltas</span>

        <span class="c1"># Add a var column of used means of the layer</span>
        <span class="n">mean_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;c_d_log1p_avg_exp&#39;</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;used_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">mean_key</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Copy the cleaned layer to the layer noisy</span>
        <span class="n">noised_layer</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">prediction_layer</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Get zero mask</span>
        <span class="n">zero_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
        <span class="c1"># Zero out the missing values</span>
        <span class="n">noised_layer</span><span class="p">[</span><span class="n">zero_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Add the layer to the adata</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;noisy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noised_layer</span>

    <span class="c1"># Give warning to say that the noisy layer is being used</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Using noisy_delta layer for training. This will probably yield bad results.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adata</span></div>


<span class="c1"># FIXME: hex_geometry default set to True (?). Check if this is needed.</span>
<span class="c1"># FIXME: Shouldn&#39;t dataset be inside the param_dict and not a parameter</span>
<span class="c1"># FIXME: Maybe the organism should be a key of the param_dict</span>
<span class="c1"># FIXME: Hex geometry should also be inside the param_dict</span>
<span class="c1"># TODO: Fix documentation when the above fixmes are solved.</span>
<div class="viewcode-block" id="process_dataset">
<a class="viewcode-back" href="../../../api/spared.processing.process_dataset.html#spared.processing.process_dataset">[docs]</a>
<span class="k">def</span> <span class="nf">process_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">param_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Perform complete processing pipeline.</span>
<span class="sd">    This function performs the complete processing pipeline for a dataset. It only computes over the expression values of the dataset</span>
<span class="sd">    (adata.X). The processing pipeline is the following:</span>

<span class="sd">        1. Normalize the data with tpm normalization (tpm layer)</span>
<span class="sd">        2. Transform the data with log1p (log1p layer)</span>
<span class="sd">        3. Denoise the data with the adaptive median filter (d_log1p layer)</span>
<span class="sd">        4. Compute moran I for each gene in each slide and average moranI across slides (add results to .var[&#39;d_log1p_moran&#39;])</span>
<span class="sd">        5. Filter dataset to keep the top param_dict[&#39;top_moran_genes&#39;] genes with highest moran I.</span>
<span class="sd">        6. Perform ComBat batch correction if specified by the &#39;combat_key&#39; parameter (c_d_log1p layer)</span>
<span class="sd">        7. Compute the deltas from the mean for each gene (computed from log1p, d_log1p and c_log1p, c_d_log1p layer if batch correction was performed)</span>
<span class="sd">        8. Add a binary mask layer specifying valid observations for metric computation (mask layer, True for valid observations, False for missing values).</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset (str): The dataset name. Must contain the substring &#39;mouse&#39; or &#39;human&#39; to specify the reference genome for TPM normalization.</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to process. Should be already filtered with the filter_dataset() function.</span>
<span class="sd">        param_dict (dict): Dictionary that contains filtering and processing parameters. Keys that must be present are:</span>

<span class="sd">                            - &#39;top_moran_genes&#39;: (int) The number of genes to keep after filtering by Moran&#39;s I. If set to 0, then the number of genes is internally computed.</span>
<span class="sd">                            - &#39;combat_key&#39;: (str) The column in adata.obs that defines the batches for ComBat batch correction. If set to &#39;None&#39;, then no batch correction is performed.</span>
<span class="sd">        </span>
<span class="sd">        hex_geometry (bool): Whether the graph is hexagonal or not. If True, then the graph is hexagonal. If False, then the graph is a grid. Only true for visium datasets.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ad.Anndata: The processed AnnData object with all the layers and results added. A list of includded layers in adata.layers is:</span>

<span class="sd">                    - &#39;counts&#39;: Raw counts of the dataset.</span>
<span class="sd">                    - &#39;tpm&#39;: TPM normalized data.</span>
<span class="sd">                    - &#39;log1p&#39;: Log1p transformed data (base 2.0).</span>
<span class="sd">                    - &#39;d_log1p&#39;: Denoised data with adaptive median filter.</span>
<span class="sd">                    - &#39;c_log1p&#39;: Batch corrected data with ComBat (only if combat_key is not &#39;None&#39;).</span>
<span class="sd">                    - &#39;c_d_log1p&#39;: Batch corrected and denoised data with adaptive median filter (only if combat_key is not &#39;None&#39;).</span>
<span class="sd">                    - &#39;deltas&#39;: Deltas from the mean expression for log1p.</span>
<span class="sd">                    - &#39;d_deltas&#39;: Deltas from the mean expression for d_log1p.</span>
<span class="sd">                    - &#39;c_deltas&#39;: Deltas from the mean expression for c_log1p (only if combat_key is not &#39;None&#39;).</span>
<span class="sd">                    - &#39;c_d_deltas&#39;: Deltas from the mean expression for c_d_log1p (only if combat_key is not &#39;None&#39;).</span>
<span class="sd">                    - &#39;mask&#39;: Binary mask layer. True for valid observations, False for imputed missing values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">### Compute all the processing steps</span>
    <span class="c1"># NOTE: The d prefix stands for denoised</span>
    <span class="c1"># NOTE: The c prefix stands for combat corrected</span>

    <span class="c1"># Start the timer and print the start message</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting data processing...&#39;</span><span class="p">)</span>

    <span class="c1"># First add raw counts to adata.layers[&#39;counts&#39;]</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;counts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    
    <span class="c1"># 1. Make TPM normalization</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">tpm_normalization</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;counts&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;tpm&#39;</span><span class="p">)</span>

    <span class="c1"># 2. Transform the data with log1p (base 2.0)</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">log1p_transformation</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;tpm&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;log1p&#39;</span><span class="p">)</span>

    <span class="c1"># 3. Denoise the data with adaptive median filter</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">clean_noise</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;log1p&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;d_log1p&#39;</span><span class="p">,</span> <span class="n">n_hops</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="o">=</span><span class="n">hex_geometry</span><span class="p">)</span>

    <span class="c1"># 4. Compute average moran for each gene in the layer d_log1p </span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">compute_moran</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="o">=</span><span class="n">hex_geometry</span><span class="p">,</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;d_log1p&#39;</span><span class="p">)</span>

    <span class="c1"># 5. Filter genes by Moran&#39;s I</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">filter_by_moran</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_keep</span><span class="o">=</span><span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;top_moran_genes&#39;</span><span class="p">],</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;d_log1p&#39;</span><span class="p">)</span>

    <span class="c1"># 6. If combat key is specified, apply batch correction</span>
    <span class="k">if</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;combat_key&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">combat_transformation</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">batch_key</span><span class="o">=</span><span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;combat_key&#39;</span><span class="p">],</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;log1p&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;c_log1p&#39;</span><span class="p">)</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">combat_transformation</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">batch_key</span><span class="o">=</span><span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;combat_key&#39;</span><span class="p">],</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;d_log1p&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;c_d_log1p&#39;</span><span class="p">)</span>

    <span class="c1"># 7. Compute deltas and mean expression for all log1p, d_log1p, c_log1p and c_d_log1p</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">get_deltas</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;log1p&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;deltas&#39;</span><span class="p">)</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">get_deltas</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;d_log1p&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;d_deltas&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;combat_key&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">get_deltas</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;c_log1p&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;c_deltas&#39;</span><span class="p">)</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">get_deltas</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">from_layer</span><span class="o">=</span><span class="s1">&#39;c_d_log1p&#39;</span><span class="p">,</span> <span class="n">to_layer</span><span class="o">=</span><span class="s1">&#39;c_d_deltas&#39;</span><span class="p">)</span>

    <span class="c1"># 8. Add a binary mask layer specifying valid observations for metric computation</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s1">&#39;tpm&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="c1"># Print with the percentage of the dataset that was replaced</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Percentage of imputed observations with median filter: </span><span class="si">{:5.3f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="o">*</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)))</span>

    <span class="c1"># Print the number of cells and genes in the dataset</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Processing of the data took </span><span class="si">{</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The processed dataset looks like this:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">adata</span></div>



<span class="c1">### Patch processing function:</span>


<span class="c1"># FIXME: keep patch_scale as parameter?</span>
<span class="c1"># TODO: Fix documentation when the above fixme is solved.</span>
<div class="viewcode-block" id="compute_patches_embeddings_and_predictions">
<a class="viewcode-back" href="../../../api/spared.processing.compute_patches_embeddings_and_predictions.html#spared.processing.compute_patches_embeddings_and_predictions">[docs]</a>
<span class="k">def</span> <span class="nf">compute_patches_embeddings_and_predictions</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">backbone</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="s1">&#39;densenet&#39;</span><span class="p">,</span> <span class="n">model_path</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="n">preds</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">224</span><span class="p">,</span> <span class="n">patch_scale</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Compute embeddings or predictions for patches.</span>
<span class="sd">    This function computes embeddings or predictions for a given backbone model and adata object. It can optionally</span>
<span class="sd">    compute using a stored model in model_path or a pretrained model from pytorch. The embeddings or predictions are</span>
<span class="sd">    stored in adata.obsm[f&#39;embeddings_{backbone}&#39;] or adata.obsm[f&#39;predictions_{backbone}&#39;] respectively. The patches</span>
<span class="sd">    must be stored in adata.obsm[f&#39;patches_scale_{patch_scale}&#39;] and must be of shape (n_patches, patch_size*patch_size*3).</span>

<span class="sd">    The function only modifies the AnnData object in place.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to process.</span>
<span class="sd">        backbone (str, optional): A string specifiying the backbone model to use. Must be one of the following [&#39;resnet&#39;, &#39;resnet50&#39;, &#39;ConvNeXt&#39;, &#39;EfficientNetV2&#39;, &#39;InceptionV3&#39;, &#39;MaxVit&#39;, &#39;MobileNetV3&#39;, &#39;ResNetXt&#39;, &#39;ShuffleNetV2&#39;, &#39;ViT&#39;, &#39;WideResnet&#39;, &#39;densenet&#39;, &#39;swin&#39;]. Defaults to &#39;densenet&#39;.</span>
<span class="sd">        model_path (str, optional): The path to a stored model. If set to &#39;None&#39;, then a pretrained model is used. Defaults to &quot;None&quot;.</span>
<span class="sd">        preds (bool, optional): True if predictions are to be computed, False if embeddings are to be computed. Defaults to True.</span>
<span class="sd">        patch_size (int, optional): The size of the patches. Defaults to 224.</span>
<span class="sd">        patch_scale (float, optional): The scale of the patches. Defaults to 1.0.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the backbone is not supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define a cuda device if available</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;cpu&#39;</span><span class="p">)</span>

    <span class="c1"># Define the model</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">im_encoder</span><span class="o">.</span><span class="n">ImageEncoder</span><span class="p">(</span><span class="n">backbone</span><span class="o">=</span><span class="n">backbone</span><span class="p">,</span> <span class="n">use_pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">latent_dim</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model_path</span> <span class="o">!=</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
        <span class="n">saved_model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
        <span class="c1"># Check if state_dict is inside a nested dictionary</span>
        <span class="k">if</span> <span class="s1">&#39;state_dict&#39;</span> <span class="ow">in</span> <span class="n">saved_model</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">saved_model</span> <span class="o">=</span> <span class="n">saved_model</span><span class="p">[</span><span class="s1">&#39;state_dict&#39;</span><span class="p">]</span>

        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">saved_model</span><span class="p">)</span>
    
    <span class="c1"># Define the weights for the model depending on the backbone</span>
    <span class="k">if</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s1">&#39;resnet&#39;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">ResNet18_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s1">&#39;resnet50&#39;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">ResNet50_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s1">&#39;ConvNeXt&#39;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">ConvNeXt_Tiny_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">classifier</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s1">&#39;EfficientNetV2&#39;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">EfficientNet_V2_S_Weights</span><span class="o">.</span><span class="n">DEFAULT</span> 
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">classifier</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s1">&#39;InceptionV3&#39;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">Inception_V3_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s2">&quot;MaxVit&quot;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">MaxVit_T_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">classifier</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s2">&quot;MobileNetV3&quot;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">MobileNet_V3_Small_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">classifier</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s2">&quot;ResNetXt&quot;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">ResNeXt50_32X4D_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s2">&quot;ShuffleNetV2&quot;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">ShuffleNet_V2_X0_5_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s2">&quot;ViT&quot;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">ViT_B_16_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s2">&quot;WideResnet&quot;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">Wide_ResNet50_2_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s1">&#39;densenet&#39;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">DenseNet121_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span> 
    <span class="k">elif</span> <span class="n">backbone</span> <span class="o">==</span> <span class="s1">&#39;swin&#39;</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">tmodels</span><span class="o">.</span><span class="n">Swin_T_Weights</span><span class="o">.</span><span class="n">DEFAULT</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Backbone </span><span class="si">{</span><span class="n">backbone</span><span class="si">}</span><span class="s1"> not supported&#39;</span><span class="p">)</span>

    <span class="c1"># Pass model to device and put in eval mode</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

    <span class="c1"># Perform specific preprocessing for the model</span>
    <span class="n">preprocess</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">transforms</span><span class="p">(</span><span class="n">antialias</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Get the patches</span>
    <span class="n">flat_patches</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;patches_scale_</span><span class="si">{</span><span class="n">patch_scale</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>

    <span class="c1"># Reshape all the patches to the original shape</span>
    <span class="n">all_patches</span> <span class="o">=</span> <span class="n">flat_patches</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">torch_patches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">all_patches</span><span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>    <span class="c1"># Turn all patches to torch</span>
    <span class="n">rescaled_patches</span> <span class="o">=</span> <span class="n">torch_patches</span> <span class="o">/</span> <span class="mi">255</span>                                       <span class="c1"># Rescale patches to [0, 1]</span>
    <span class="n">processed_patches</span> <span class="o">=</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">rescaled_patches</span><span class="p">)</span>                             <span class="c1"># Preprocess patches</span>
    
    <span class="c1"># Create a dataloader</span>
    <span class="n">dataloader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">processed_patches</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Declare lists to store the embeddings or predictions</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        
        <span class="k">if</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="s1">&#39;Getting predictions&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="s1">&#39;Getting embeddings&#39;</span>
        
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">):</span>
            <span class="n">batch</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>                    <span class="c1"># Send batch to device                </span>
            <span class="n">batch_output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>                 <span class="c1"># Get embeddings or predictions</span>
            <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_output</span><span class="p">)</span>                <span class="c1"># Append to list</span>


    <span class="c1"># Concatenate all embeddings or predictions</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Pass embeddings or predictions to cpu and add to data.obsm</span>
    <span class="k">if</span> <span class="n">preds</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;predictions_</span><span class="si">{</span><span class="n">backbone</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputs</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;embeddings_</span><span class="si">{</span><span class="n">backbone</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outputs</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span></div>



<span class="c1">### Adata dataloader building function:</span>

<span class="c1"># TODO: Fix the internal fixme</span>
<div class="viewcode-block" id="get_pretrain_dataloaders">
<a class="viewcode-back" href="../../../api/spared.processing.get_pretrain_dataloaders.html#spared.processing.get_pretrain_dataloaders">[docs]</a>
<span class="k">def</span> <span class="nf">get_pretrain_dataloaders</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;c_d_log1p&#39;</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span> <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">use_cuda</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">AnnLoader</span><span class="p">,</span> <span class="n">AnnLoader</span><span class="p">,</span> <span class="n">AnnLoader</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get dataloaders for pretraining an image encoder.</span>
<span class="sd">    This function returns the dataloaders for training an image encoder. This means training a purely vision-based model on only</span>
<span class="sd">    the patches to predict the gene expression of the patches.</span>

<span class="sd">    Dataloaders are returned as a tuple, if there is no test set for the dataset, then the test dataloader is None.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object that will be processed.</span>
<span class="sd">        layer (str, optional): The layer to use for the pre-training. The adata.X will be set to that of &#39;layer&#39;. Defaults to &#39;deltas&#39;.</span>
<span class="sd">        batch_size (int, optional): The batch size of the loaders. Defaults to 128.</span>
<span class="sd">        shuffle (bool, optional): Whether to shuffle the data in the loaders. Defaults to True.</span>
<span class="sd">        use_cuda (bool, optional): True for using cuda in the loader. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[AnnLoader, AnnLoader, AnnLoader]: The train, validation and test dataloaders. If there is no test set, the test dataloader is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the sample indexes for the train, validation and test sets</span>
    <span class="n">idx_train</span><span class="p">,</span> <span class="n">idx_val</span><span class="p">,</span> <span class="n">idx_test</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">split</span> <span class="o">==</span> <span class="s1">&#39;train&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">split</span> <span class="o">==</span> <span class="s1">&#39;val&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">split</span> <span class="o">==</span> <span class="s1">&#39;test&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>

    <span class="c1">##### Addition to handle noisy training #####</span>

    <span class="c1"># FIXME: Put this in a part of the complete processing pipeline instead of the dataloader function.</span>
    <span class="c1"># Handle noisy training</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">add_noisy_layer</span><span class="p">(</span><span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span> <span class="n">prediction_layer</span><span class="o">=</span><span class="n">layer</span><span class="p">)</span>

    <span class="c1"># Set the X of the adata to the layer casted to float32</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">imp_model_str</span> <span class="o">=</span> <span class="s1">&#39;transformer model&#39;</span> <span class="k">if</span> <span class="n">layer</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;c_t_log1p&#39;</span><span class="p">,</span> <span class="s1">&#39;c_t_deltas&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;median filter&#39;</span>

    <span class="c1"># Print with the percentage of the dataset that was replaced</span>
    <span class="n">imp_pct</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span><span class="o">*</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Percentage of imputed observations with </span><span class="si">{}</span><span class="s1">: </span><span class="si">{:5.3f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">imp_model_str</span><span class="p">,</span> <span class="n">imp_pct</span><span class="p">))</span>

    <span class="c1"># If the prediction layer is some form of deltas, add the used mean of the layer as a column in the var</span>
    <span class="k">if</span> <span class="s1">&#39;deltas&#39;</span> <span class="ow">in</span> <span class="n">layer</span><span class="p">:</span>
        <span class="c1"># Add a var column of used means of the layer</span>
        <span class="n">mean_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer</span><span class="si">}</span><span class="s1">_avg_exp&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;deltas&#39;</span><span class="p">,</span> <span class="s1">&#39;log1p&#39;</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;used_mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">mean_key</span><span class="p">]</span>

    <span class="c1"># Subset the global data handle also the possibility that there is no test set</span>
    <span class="n">adata_train</span><span class="p">,</span> <span class="n">adata_val</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">idx_train</span><span class="p">,</span> <span class="p">:],</span> <span class="n">adata</span><span class="p">[</span><span class="n">idx_val</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">adata_test</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">idx_test</span><span class="p">,</span> <span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># Declare dataloaders</span>
    <span class="n">train_dataloader</span> <span class="o">=</span> <span class="n">AnnLoader</span><span class="p">(</span><span class="n">adata_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">use_cuda</span><span class="o">=</span><span class="n">use_cuda</span><span class="p">)</span>
    <span class="n">val_dataloader</span> <span class="o">=</span> <span class="n">AnnLoader</span><span class="p">(</span><span class="n">adata_val</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">use_cuda</span><span class="o">=</span><span class="n">use_cuda</span><span class="p">)</span>
    <span class="n">test_dataloader</span> <span class="o">=</span> <span class="n">AnnLoader</span><span class="p">(</span><span class="n">adata_test</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span> <span class="n">use_cuda</span><span class="o">=</span><span class="n">use_cuda</span><span class="p">)</span> <span class="k">if</span> <span class="n">adata_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">train_dataloader</span><span class="p">,</span> <span class="n">val_dataloader</span><span class="p">,</span> <span class="n">test_dataloader</span></div>



<span class="c1">### Graph building functions:</span>

<div class="viewcode-block" id="get_graphs_one_slide">
<a class="viewcode-back" href="../../../api/spared.processing.get_graphs_one_slide.html#spared.processing.get_graphs_one_slide">[docs]</a>
<span class="k">def</span> <span class="nf">get_graphs_one_slide</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get neighbor graphs for a single slide.</span>
<span class="sd">    This function receives an AnnData object with a single slide and for each node computes the graph in an</span>
<span class="sd">    n_hops radius in a pytorch geometric format. The AnnData object must have both embeddings and predictions in the</span>
<span class="sd">    adata.obsm attribute.</span>

<span class="sd">    It returns a dictionary where the patch names are the keys and a pytorch geometric graph for each one as</span>
<span class="sd">    values. NOTE: The first node of every graph is the center.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object with the slide data.</span>
<span class="sd">        n_hops (int): The number of hops to compute the graph.</span>
<span class="sd">        layer (str): The layer of the graph to predict. Will be added as y to the graph.</span>
<span class="sd">        hex_geometry (bool): Whether the slide has hexagonal geometry or not.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple(dict,int)</span>
<span class="sd">        dict: A dictionary where the patch names are the keys and pytorch geometric graph for each one as values. The first node of every graph is the center.</span>
<span class="sd">        int: Max column or row difference between the center and the neighbors. Used for positional encoding.                   </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute spatial_neighbors</span>
    <span class="k">if</span> <span class="n">hex_geometry</span><span class="p">:</span>
        <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s1">&#39;generic&#39;</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span> <span class="c1"># Hexagonal visium case</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># Grid STNet dataset case</span>

    <span class="c1"># Get the adjacency matrix</span>
    <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s1">&#39;spatial_connectivities&#39;</span><span class="p">]</span>

    <span class="c1"># Define power matrix</span>
    <span class="n">power_matrix</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># Define the output matrix</span>
    <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Iterate through the hops</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_hops</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Compute the next hop</span>
        <span class="n">power_matrix</span> <span class="o">=</span> <span class="n">power_matrix</span> <span class="o">*</span> <span class="n">adj_matrix</span>
        <span class="c1"># Add the next hop to the output matrix</span>
        <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">output_matrix</span> <span class="o">+</span> <span class="n">power_matrix</span>

    <span class="c1"># Zero out the diagonal</span>
    <span class="n">output_matrix</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Threshold the matrix to 0 and 1</span>
    <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">output_matrix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Define dict from index to obs name</span>
    <span class="n">index_to_obs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">obs</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)}</span>

    <span class="c1"># Define neighbors dicts (one with names and one with indexes)</span>
    <span class="n">neighbors_dict_index</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">neighbors_dict_names</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">matrices_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Iterate through the rows of the output matrix</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">output_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># Get the non-zero elements of the row</span>
        <span class="n">non_zero_elements</span> <span class="o">=</span> <span class="n">output_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Get the names of the neighbors</span>
        <span class="n">non_zero_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_to_obs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">non_zero_elements</span><span class="p">]</span>
        <span class="c1"># Add the neighbors to the neighbors dicts. NOTE: the first index is the query obs</span>
        <span class="n">neighbors_dict_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">non_zero_elements</span><span class="p">)</span>
        <span class="n">neighbors_dict_names</span><span class="p">[</span><span class="n">index_to_obs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">index_to_obs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">non_zero_names</span><span class="p">)</span>
        
        <span class="c1"># Subset the matrix to the non-zero elements and store it in the matrices dict</span>
        <span class="n">matrices_dict</span><span class="p">[</span><span class="n">index_to_obs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">output_matrix</span><span class="p">[</span><span class="n">neighbors_dict_index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:][:,</span> <span class="n">neighbors_dict_index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    
    <span class="c1">### Get pytorch geometric graphs ###</span>
    <span class="n">layers_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">key</span><span class="p">])</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="c1"># Get global layers</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[[</span><span class="s1">&#39;array_row&#39;</span><span class="p">,</span> <span class="s1">&#39;array_col&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>                                        <span class="c1"># Get global positions</span>

    <span class="c1"># Get embeddings and predictions keys</span>
    <span class="n">emb_key_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;embeddings&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
    <span class="n">pred_key_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;predictions&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">emb_key_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;There are more than 1 or no embedding keys in adata.obsm&#39;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pred_key_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;There are more than 1 or no prediction keys in adata.obsm&#39;</span>
    <span class="n">emb_key</span><span class="p">,</span> <span class="n">pred_key</span> <span class="o">=</span> <span class="n">emb_key_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pred_key_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If embeddings and predictions are present in obsm, get them</span>
    <span class="n">embeddings</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="n">emb_key</span><span class="p">])</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="n">pred_key</span><span class="p">])</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># If layer contains delta then add a used_mean attribute to the graph</span>
    <span class="n">used_mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">layer</span><span class="si">}</span><span class="s1">_avg_exp&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;deltas&#39;</span><span class="p">,</span> <span class="s1">&#39;log1p&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;deltas&#39;</span> <span class="ow">in</span> <span class="n">layer</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># Define the empty graph dict</span>
    <span class="n">graph_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">max_abs_d_pos</span><span class="o">=-</span><span class="mi">1</span>

    <span class="c1"># Cycle over each obs</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors_dict_index</span><span class="p">)),</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">central_node_name</span> <span class="o">=</span> <span class="n">index_to_obs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>                                                 <span class="c1"># Get the name of the central node</span>
        <span class="n">curr_nodes_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">neighbors_dict_index</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>                              <span class="c1"># Get the indexes of the nodes in the graph</span>
        <span class="n">curr_adj_matrix</span> <span class="o">=</span> <span class="n">matrices_dict</span><span class="p">[</span><span class="n">central_node_name</span><span class="p">]</span>                                  <span class="c1"># Get the adjacency matrix of the graph (precomputed)</span>
        <span class="n">curr_edge_index</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">curr_adj_matrix</span><span class="p">)</span>                      <span class="c1"># Get the edge index and edge attribute of the graph</span>
        <span class="n">curr_layers</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">layers_dict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">curr_nodes_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">layers_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="c1"># Get the layers of the graph filtered by the nodes</span>
        <span class="n">curr_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">curr_nodes_idx</span><span class="p">]</span>                                                      <span class="c1"># Get the positions of the nodes in the graph</span>
        <span class="n">curr_d_pos</span> <span class="o">=</span> <span class="n">curr_pos</span> <span class="o">-</span> <span class="n">curr_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                                                 <span class="c1"># Get the relative positions of the nodes in the graph</span>

        <span class="c1"># Define the graph</span>
        <span class="n">graph_dict</span><span class="p">[</span><span class="n">central_node_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">geo_Data</span><span class="p">(</span>
            <span class="n">y</span><span class="o">=</span><span class="n">curr_layers</span><span class="p">[</span><span class="n">layer</span><span class="p">],</span>
            <span class="n">edge_index</span><span class="o">=</span><span class="n">curr_edge_index</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">curr_pos</span><span class="p">,</span>
            <span class="n">d_pos</span><span class="o">=</span><span class="n">curr_d_pos</span><span class="p">,</span>
            <span class="n">embeddings</span><span class="o">=</span><span class="n">embeddings</span><span class="p">[</span><span class="n">curr_nodes_idx</span><span class="p">],</span>
            <span class="n">predictions</span><span class="o">=</span><span class="n">predictions</span><span class="p">[</span><span class="n">curr_nodes_idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">predictions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">used_mean</span><span class="o">=</span><span class="n">used_mean</span> <span class="k">if</span> <span class="n">used_mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">num_nodes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_nodes_idx</span><span class="p">),</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">layers_dict</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">][</span><span class="n">curr_nodes_idx</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">max_curr_d_pos</span><span class="o">=</span><span class="n">curr_d_pos</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_curr_d_pos</span><span class="o">&gt;</span><span class="n">max_abs_d_pos</span><span class="p">:</span>
            <span class="n">max_abs_d_pos</span><span class="o">=</span><span class="n">max_curr_d_pos</span>

    <span class="c1">#cast as int</span>
    <span class="n">max_abs_d_pos</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">max_abs_d_pos</span><span class="p">)</span>
    
    <span class="c1"># Return the graph dict</span>
    <span class="k">return</span> <span class="n">graph_dict</span><span class="p">,</span> <span class="n">max_abs_d_pos</span></div>



<div class="viewcode-block" id="get_sin_cos_positional_embeddings">
<a class="viewcode-back" href="../../../api/spared.processing.get_sin_cos_positional_embeddings.html#spared.processing.get_sin_cos_positional_embeddings">[docs]</a>
<span class="k">def</span> <span class="nf">get_sin_cos_positional_embeddings</span><span class="p">(</span><span class="n">graph_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">max_d_pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get positional encodings for a neighbor graph.</span>
<span class="sd">    This function adds a transformer-like positional encodings to each graph in a graph dict. It adds the positional</span>
<span class="sd">    encodings under the attribute &#39;positional_embeddings&#39; for each graph. </span>

<span class="sd">    Args:</span>
<span class="sd">        graph_dict (dict): A dictionary where the patch names are the keys and a pytorch geometric graphs for each one are values.</span>
<span class="sd">        max_d_pos (int): Max absolute value in the relative position matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The input graph dict with the information of positional encodings for each graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph_dict_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">embedding_dim</span> <span class="o">=</span> <span class="n">graph_dict</span><span class="p">[</span><span class="n">graph_dict_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">embeddings</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Define the positional encoding model</span>
    <span class="n">p_encoding_model</span><span class="o">=</span> <span class="n">PositionalEncoding2D</span><span class="p">(</span><span class="n">embedding_dim</span><span class="p">)</span>

    <span class="c1"># Define the empty grid with size (batch_size, x, y, channels)</span>
    <span class="n">grid_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">max_d_pos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">max_d_pos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">])</span>

    <span class="c1"># Obtain the embeddings for each position</span>
    <span class="n">positional_look_up_table</span> <span class="o">=</span> <span class="n">p_encoding_model</span><span class="p">(</span><span class="n">grid_size</span><span class="p">)</span>        

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">graph_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">d_pos</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">d_pos</span>
        <span class="n">grid_pos</span> <span class="o">=</span> <span class="n">d_pos</span> <span class="o">+</span> <span class="n">max_d_pos</span>
        <span class="n">graph_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">positional_embeddings</span> <span class="o">=</span> <span class="n">positional_look_up_table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">grid_pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">grid_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],:]</span>
    
    <span class="k">return</span> <span class="n">graph_dict</span></div>



<div class="viewcode-block" id="get_graphs">
<a class="viewcode-back" href="../../../api/spared.processing.get_graphs.html#spared.processing.get_graphs">[docs]</a>
<span class="k">def</span> <span class="nf">get_graphs</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get graphs for all the slides in a dataset.</span>
<span class="sd">    This function wraps the get_graphs_one_slide function to get the graphs for all the slides in the dataset.</span>
<span class="sd">    After computing the graph dicts for each slide it concatenates them into a single dictionary which is then used to compute</span>
<span class="sd">    the positional embeddings for each graph.</span>

<span class="sd">    For details see get_graphs_one_slide and get_sin_cos_positional_embeddings functions.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object used to build the graphs.</span>
<span class="sd">        n_hops (int): The number of hops to compute each graph.</span>
<span class="sd">        layer (str): The layer of the graph to predict. Will be added as y to the graph.</span>
<span class="sd">        hex_geometry (bool): Whether the graph is hexagonal or not. Only true for visium datasets. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary where the spots&#39; names are the keys and pytorch geometric graphs are values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing graphs...&#39;</span><span class="p">)</span>

    <span class="c1"># Get unique slide ids</span>
    <span class="n">unique_ids</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;slide_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="c1"># Global dictionary to store the graphs (pytorch geometric graphs)</span>
    <span class="n">graph_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">max_global_d_pos</span><span class="o">=-</span><span class="mi">1</span>

    <span class="c1"># Iterate through slides</span>
    <span class="k">for</span> <span class="n">slide</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">unique_ids</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">curr_adata</span> <span class="o">=</span> <span class="n">get_slide_from_collection</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">slide</span><span class="p">)</span>
        <span class="n">curr_graph_dict</span><span class="p">,</span> <span class="n">max_curr_d_pos</span> <span class="o">=</span> <span class="n">get_graphs_one_slide</span><span class="p">(</span><span class="n">curr_adata</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">)</span>
        
        <span class="c1"># Join the current dictionary to the global dictionary</span>
        <span class="n">graph_dict</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">graph_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">curr_graph_dict</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">max_curr_d_pos</span><span class="o">&gt;</span><span class="n">max_global_d_pos</span><span class="p">:</span>
            <span class="n">max_global_d_pos</span><span class="o">=</span><span class="n">max_curr_d_pos</span>
    
    <span class="n">graph_dict</span> <span class="o">=</span> <span class="n">get_sin_cos_positional_embeddings</span><span class="p">(</span><span class="n">graph_dict</span><span class="p">,</span> <span class="n">max_global_d_pos</span><span class="p">)</span>

    <span class="c1"># Return the graph dict</span>
    <span class="k">return</span> <span class="n">graph_dict</span></div>


<span class="c1"># TODO: Fix the internal fixme</span>
<div class="viewcode-block" id="get_graph_dataloaders">
<a class="viewcode-back" href="../../../api/spared.processing.get_graph_dataloaders.html#spared.processing.get_graph_dataloaders">[docs]</a>
<span class="k">def</span> <span class="nf">get_graph_dataloaders</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">dataset_path</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;c_t_log1p&#39;</span><span class="p">,</span> <span class="n">n_hops</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">backbone</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">model_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;best_stnet.pt&quot;</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span> 
                          <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">patch_scale</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">geo_DataLoader</span><span class="p">,</span> <span class="n">geo_DataLoader</span><span class="p">,</span> <span class="n">geo_DataLoader</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get dataloaders for the graphs of a dataset.</span>
<span class="sd">    This function performs all the pipeline to get graphs dataloaders for a dataset. It does the following steps:</span>

<span class="sd">        1. Computes embeddings and predictions for the patches using the specified backbone and model.</span>
<span class="sd">        2. Computes the graph dictionaries for the dataset using the embeddings and predictions.</span>
<span class="sd">        3. Saves the graphs in the dataset_path folder.</span>
<span class="sd">        4. Returns the train, validation and test dataloaders for the graphs.</span>
<span class="sd">    </span>
<span class="sd">    The function also checks if the graphs are already saved in the dataset_path folder. If they are, it loads them instead of recomputing them. In case </span>
<span class="sd">    the dataset has no test set, the test dataloader is set to None.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (ad.AnnData): The AnnData object to process.</span>
<span class="sd">        dataset_path (str, optional): The path to the dataset (where the graphs will be stored). Defaults to &#39;&#39;.</span>
<span class="sd">        layer (str, optional): Layer to predict. Defaults to &#39;c_t_log1p&#39;.</span>
<span class="sd">        n_hops (int, optional): Number of hops to compute the graph. Defaults to 2.</span>
<span class="sd">        backbone (str, optional): Backbone model to use. Defaults to &#39;densenet&#39;.</span>
<span class="sd">        model_path (str, optional): Path to the model to use. Defaults to &quot;None&quot;.</span>
<span class="sd">        batch_size (int, optional): Batch size of the dataloaders. Defaults to 128.</span>
<span class="sd">        shuffle (bool, optional): Whether to shuffle the data in the dataloaders. Defaults to True.</span>
<span class="sd">        hex_geometry (bool, optional): Whether the graph is hexagonal or not. Defaults to True.</span>
<span class="sd">        patch_size (int, optional): Size of the patches. Defaults to 224.</span>
<span class="sd">        patch_scale (float, optional): Scale of the patches. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[geo_DataLoader, geo_DataLoader, geo_DataLoader]: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get dictionary of parameters to get the graphs</span>
    <span class="n">curr_graph_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;n_hops&#39;</span><span class="p">:</span> <span class="n">n_hops</span><span class="p">,</span>
        <span class="s1">&#39;layer&#39;</span><span class="p">:</span> <span class="n">layer</span><span class="p">,</span>
        <span class="s1">&#39;backbone&#39;</span><span class="p">:</span> <span class="n">backbone</span><span class="p">,</span>
        <span class="s1">&#39;model_path&#39;</span><span class="p">:</span> <span class="n">model_path</span>
    <span class="p">}</span>        

    <span class="c1"># Create graph directory if it does not exist</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">,</span> <span class="s1">&#39;graphs&#39;</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Get the filenames of the parameters of all directories in the graph folder</span>
    <span class="n">filenames</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">,</span> <span class="s1">&#39;graphs&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_params.json&#39;</span> <span class="p">),</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Define boolean to check if the graphs are already saved</span>
    <span class="n">found_graphs</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Iterate over all the filenames and check if the parameters are the same</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Load the parameters of the dataset</span>
            <span class="n">saved_params</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="c1"># Check if the parameters are the same</span>
            <span class="k">if</span> <span class="n">saved_params</span> <span class="o">==</span> <span class="n">curr_graph_params</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Graph data already saved in </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">found_graphs</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Track the time and load the graphs</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
                <span class="n">train_graphs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s1">&#39;train_graphs.pt&#39;</span><span class="p">))</span>
                <span class="n">val_graphs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s1">&#39;val_graphs.pt&#39;</span><span class="p">))</span>
                <span class="n">test_graphs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s1">&#39;test_graphs.pt&#39;</span><span class="p">))</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s1">&#39;test_graphs.pt&#39;</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loaded graphs in </span><span class="si">{</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds.&#39;</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="c1"># If the graphs are not found, compute them</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_graphs</span><span class="p">:</span>
        
        <span class="c1"># Print that we are computing the graphs</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Graphs not found in file, computing graphs...&#39;</span><span class="p">)</span>

        <span class="c1"># FIXME: Again this should be in the processing part and not in the dataloader</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">add_noisy_layer</span><span class="p">(</span><span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span> <span class="n">prediction_layer</span><span class="o">=</span><span class="n">layer</span><span class="p">)</span>

        <span class="c1"># We compute the embeddings and predictions for the patches</span>
        <span class="n">compute_patches_embeddings_and_predictions</span><span class="p">(</span><span class="n">preds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">backbone</span><span class="o">=</span><span class="n">backbone</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="n">patch_size</span><span class="p">,</span> <span class="n">patch_scale</span><span class="o">=</span><span class="n">patch_scale</span><span class="p">)</span>
        <span class="n">compute_patches_embeddings_and_predictions</span><span class="p">(</span><span class="n">preds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">backbone</span><span class="o">=</span><span class="n">backbone</span><span class="p">,</span> <span class="n">model_path</span><span class="o">=</span><span class="n">model_path</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="n">patch_size</span><span class="p">,</span> <span class="n">patch_scale</span><span class="o">=</span><span class="n">patch_scale</span><span class="p">)</span>
        
        <span class="c1"># Get graph dicts</span>
        <span class="n">general_graph_dict</span> <span class="o">=</span> <span class="n">get_graphs</span><span class="p">(</span><span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_hops</span><span class="o">=</span><span class="n">n_hops</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span> <span class="n">hex_geometry</span><span class="o">=</span><span class="n">hex_geometry</span><span class="p">)</span>

        <span class="c1"># Get the train, validation and test indexes</span>
        <span class="n">idx_train</span><span class="p">,</span> <span class="n">idx_val</span><span class="p">,</span> <span class="n">idx_test</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">split</span> <span class="o">==</span> <span class="s1">&#39;train&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">split</span> <span class="o">==</span> <span class="s1">&#39;val&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">split</span> <span class="o">==</span> <span class="s1">&#39;test&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>

        <span class="c1"># Get list of graphs</span>
        <span class="n">train_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">general_graph_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx_train</span><span class="p">]</span>
        <span class="n">val_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">general_graph_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx_val</span><span class="p">]</span>
        <span class="n">test_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">general_graph_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx_test</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Saving graphs...&#39;</span><span class="p">)</span>
        <span class="c1"># Create graph directory if it does not exist with the current time</span>
        <span class="n">graph_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dataset_path</span><span class="p">,</span> <span class="s1">&#39;graphs&#39;</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-%m-%Y-%H-%M-%S&quot;</span><span class="p">))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">graph_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Save the graph parameters</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">graph_dir</span><span class="p">,</span> <span class="s1">&#39;graph_params.json&#39;</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Write the json</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">curr_graph_params</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">train_graphs</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">graph_dir</span><span class="p">,</span> <span class="s1">&#39;train_graphs.pt&#39;</span><span class="p">))</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">val_graphs</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">graph_dir</span><span class="p">,</span> <span class="s1">&#39;val_graphs.pt&#39;</span><span class="p">))</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">test_graphs</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">graph_dir</span><span class="p">,</span> <span class="s1">&#39;test_graphs.pt&#39;</span><span class="p">))</span> <span class="k">if</span> <span class="n">test_graphs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    

    <span class="c1"># Declare dataloaders</span>
    <span class="n">train_dataloader</span> <span class="o">=</span> <span class="n">geo_DataLoader</span><span class="p">(</span><span class="n">train_graphs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">)</span>
    <span class="n">val_dataloader</span> <span class="o">=</span> <span class="n">geo_DataLoader</span><span class="p">(</span><span class="n">val_graphs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">)</span>
    <span class="n">test_dataloader</span> <span class="o">=</span> <span class="n">geo_DataLoader</span><span class="p">(</span><span class="n">test_graphs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">)</span> <span class="k">if</span> <span class="n">test_graphs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">train_dataloader</span><span class="p">,</span> <span class="n">val_dataloader</span><span class="p">,</span> <span class="n">test_dataloader</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Gabriel Mejia, Daniela Ruiz, Paula Cardenas, Leonardo Manrique, Daniela Vega &amp; Pablo Arbelaez.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>